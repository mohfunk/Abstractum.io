{"id":"../src/content/blog/6.rust.md","dependencies":[],"generated":{"html":"<hr>\n<p>Rust Memory Management\n2019 Feb\nblog</p>\n<hr>\n<h1 id=\"rusts-memory-management-system\">Rust&#39;s Memory Management System</h1>\n<h6 id=\"feb-2019\">Feb 2019</h6>\n<h5 id=\"draft-work-in-progress\">[draft, work in progress]</h5>\n<h2 id=\"background\">Background</h2>\n<p>Operating systems provide an abstraction of physical memory to each running\nprogram called <strong>A Virtual Address Space,</strong> for now, assume an address space contains 3 sections:   </p>\n<ul>\n<li>An Instruction section<br>Where the program Instructions live.</li>\n<li>A <strong>Stack</strong><br>To track function calls, store local variables, function arguments, and return\nvalues.</li>\n<li>A <strong>Heap</strong><br>For User-managed, dynamically (or runtime) alloacated memory.</li>\n</ul>\n<p>The stack is structured to follow a strict <em>first in, last out</em> policy; thus,\ninserting, deleting, or accessing data on the stack doesnt require intensive\ncomputation. However, data stored on the stack must have a known size at compile\ntime that must remain fixed and they cant be used beyond their scope. To address these limitations, we store data of\nunknown and/or dynamic size on the heap.   </p>\n<p>Since Heaps lack the determinism of stacks, They cost more to manage and there has been two common approches for managing heap allocated memory:  </p>\n<ul>\n<li><p><strong>Garbage Collection</strong><br>Garbage collected languages manage memory automatically which\ncomes at a runtime performance cost.</p>\n</li>\n<li><p><strong>Manual Management</strong><br>Memory is managed exlicity by the programmer. Managing memory manually is an\nerror-prone process that demands careful attention, common bugs include:</p>\n<ul>\n<li><strong>Segmentation Faults</strong><br>Performing an operation on Memory that is was not alloacted.</li>\n<li><strong>Buffer Overflow</strong><br>Alloacted Memory is not enough.   </li>\n<li><strong>Memory Leaks</strong><br>Memory allocated is not freed; and thus, wasted.   </li>\n<li><strong>Invalid Access</strong><br>Attempting to access already dealocated memory, or failing to alloact\nproperly.   </li>\n<li><strong>free on unallocated memory</strong><br>Attempting to dealocate already dealocated memory.  </li>\n</ul>\n</li>\n</ul>\n<p>Rust introduces a 3rd novel approch that is not as compuationally expensive as\nGarbage Collection, and not as error-prone as Dynamic allocation/deallocation: <strong>Ownership.</strong>   </p>\n<h3 id=\"rules\">Rules</h3>\n<ul>\n<li>A <em>Variable</em> carrying A Value is the <strong>Owner</strong> of that Value.</li>\n<li>There can only be <em><strong>one</strong></em> owner at a time.</li>\n<li>When an owner goes out of scope, the value is <strong>dropped</strong></li>\n</ul>\n<blockquote>\n<p><strong>Dropped</strong> is rust&#39;s term for <em>Deallocated</em></p>\n</blockquote>\n"},"sourceMaps":null,"error":null,"hash":"e9ce5656a0ca95f0bd98204ac172be49","cacheData":{}}