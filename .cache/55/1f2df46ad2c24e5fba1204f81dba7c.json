{"id":"RQA8","dependencies":[],"generated":{"html":"<hr><p>Rust Memory Management\n2019 Feb\nblog</p><hr><h1 id=\"rusts-memory-management-system\">Rust&#39;s Memory Management System</h1><h6 id=\"feb-2019\">Feb 2019</h6><h5 id=\"draft-work-in-progress\">[draft, work in progress]</h5><h2 id=\"background\">Background</h2><p>Operating systems provide an abstraction of physical memory to each running\nprogram called <strong>A Virtual Address Space,</strong> for now, assume an address space contains 3 sections: </p><ul>\n<li>An Instruction section<br>Where the program Instructions live.</li>\n<li>A <strong>Stack</strong><br>To track function calls, store local variables, function arguments, and return\nvalues.</li>\n<li>A <strong>Heap</strong><br>For User-managed, dynamically (or runtime) alloacated memory.</li>\n</ul><p>The stack is structured to follow a strict <em>first in, last out</em> policy; thus,\ninserting, deleting, or accessing data on the stack doesnt require intensive\ncomputation. However, data stored on the stack must have a known size at compile\ntime that must remain fixed and they cant be used beyond their scope. To address these limitations, we store data of\nunknown and/or dynamic size on the heap. </p><p>Since Heaps lack the determinism of stacks, They cost more to manage and there has been two common approches for managing heap allocated memory: </p><ul>\n<li><p><strong>Garbage Collection</strong><br>Garbage collected languages manage memory automatically which\ncomes at a runtime performance cost.</p>\n</li>\n<li><p><strong>Manual Management</strong><br>Memory is managed exlicity by the programmer. Managing memory manually is an\nerror-prone process that demands careful attention, common bugs include:</p>\n<ul>\n<li><strong>Segmentation Faults</strong><br>Performing an operation on Memory that is was not alloacted.</li>\n<li><strong>Buffer Overflow</strong><br>Alloacted Memory is not enough. </li>\n<li><strong>Memory Leaks</strong><br>Memory allocated is not freed; and thus, wasted. </li>\n<li><strong>Invalid Access</strong><br>Attempting to access already dealocated memory, or failing to alloact\nproperly. </li>\n<li><strong>free on unallocated memory</strong><br>Attempting to dealocate already dealocated memory. </li>\n</ul>\n</li>\n</ul><p>Rust introduces a 3rd novel approch that is not as compuationally expensive as\nGarbage Collection, and not as error-prone as Dynamic allocation/deallocation: <strong>Ownership.</strong> </p><h3 id=\"rules\">Rules</h3><ul>\n<li>A <em>Variable</em> carrying A Value is the <strong>Owner</strong> of that Value.</li>\n<li>There can only be <em><strong>one</strong></em> owner at a time.</li>\n<li>When an owner goes out of scope, the value is <strong>dropped</strong></li>\n</ul><blockquote>\n<p><strong>Dropped</strong> is rust&#39;s term for <em>Deallocated</em></p>\n</blockquote>"},"sourceMaps":null,"error":null,"hash":"ba1717a038279b66007099d81625bb09","cacheData":{}}