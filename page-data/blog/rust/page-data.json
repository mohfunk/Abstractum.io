{"componentChunkName":"component---src-components-page-tsx","path":"/blog/rust/","webpackCompilationHash":"1ceac6daed755874f799","result":{"data":{"mdx":{"id":"d3d8ad1b-c5ef-5f21-a2a3-8c3d66373fd5","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rust Memory Management\",\n  \"date\": \"2019.02.14\",\n  \"group\": \"blog\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Rust's Memory Management System\"), mdx(\"h6\", null, \"Feb 2019\"), mdx(\"h5\", null, \"[draft, work in progress]\"), mdx(\"h2\", null, \"Background\"), mdx(\"p\", null, \"Operating systems provide an abstraction of physical memory to each running\\nprogram called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A Virtual Address Space,\"), \" for now, assume an address space contains 3 sections:   \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An Instruction section\", mdx(\"br\", {\n    parentName: \"li\"\n  }), \"Where the program Instructions live.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Stack\"), mdx(\"br\", {\n    parentName: \"li\"\n  }), \"To track function calls, store local variables, function arguments, and return\\nvalues.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Heap\"), mdx(\"br\", {\n    parentName: \"li\"\n  }), \"For User-managed, dynamically (or runtime) alloacated memory.\")), mdx(\"p\", null, \"The stack is structured to follow a strict \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"first in, last out\"), \" policy; thus,\\ninserting, deleting, or accessing data on the stack doesnt require intensive\\ncomputation. However, data stored on the stack must have a known size at compile\\ntime that must remain fixed and they cant be used beyond their scope. To address these limitations, we store data of\\nunknown and/or dynamic size on the heap.   \"), mdx(\"p\", null, \"Since Heaps lack the determinism of stacks, They cost more to manage and there has been two common approches for managing heap allocated memory:  \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Garbage Collection\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Garbage collected languages manage memory automatically which\\ncomes at a runtime performance cost.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Manual Management\"), mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Memory is managed exlicity by the programmer. Managing memory manually is an\\nerror-prone process that demands careful attention, common bugs include:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"* **Segmentation Faults**  \\nPerforming an operation on Memory that is was not alloacted.\\n* **Buffer Overflow**  \\nAlloacted Memory is not enough.   \\n* **Memory Leaks**  \\nMemory allocated is not freed; and thus, wasted.   \\n* **Invalid Access**  \\nAttempting to access already dealocated memory, or failing to alloact\\nproperly.   \\n* **free on unallocated memory**  \\nAttempting to dealocate already dealocated memory.  \\n\")))), mdx(\"p\", null, \"Rust introduces a 3rd novel approch that is not as compuationally expensive as\\nGarbage Collection, and not as error-prone as Dynamic allocation/deallocation: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ownership.\"), \"   \"), mdx(\"h3\", null, \"Rules\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Variable\"), \" carrying A Value is the \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Owner\"), \" of that Value.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There can only be \", mdx(\"em\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"one\")), \" owner at a time.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When an owner goes out of scope, the value is \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"dropped\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dropped\"), \" is rust's term for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Deallocated\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Rust Memory Management","group":"blog"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"d3d8ad1b-c5ef-5f21-a2a3-8c3d66373fd5"}}}